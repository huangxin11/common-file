js基础
	原生操作dom：
		appendChild()  --->需要提前使用createElement()创建标签
		加在第一个标签之前（或者目标元素之后，需传入第二个参数，targetElemenet.nextSibling）
			insertBefore()

	虚拟dom
		每一次dom变动，页面就会重新渲染一次，为了页面性能，就应该要减少dom操作。现代框架会用一个对象来存储dom节点的标签名，属性，内容，子节点等信息，也就是用js的对象结构来表示dom树的结构，这个js对象就是虚拟dom。当状态变更的时候，js会先更新虚拟dom,再通过diff算法，比较虚拟DOM和真实dom的差异，找出最少变更的方案，最后一并更新到真实dom中。

	为什么虚拟dom最终也是会更新真实dom，但是效率会更高呢
		全程操作真实dom的话，任何一个状态变更都会导致页面重绘，这个环节就比较消耗性能。采用虚拟dom的话，就能避免这个问题，而且如果diff算法效率高的话，总能用最少的改动来更新dom。总的来说，就是不会出现频繁的，大面积的dom操作，从而提升了效率

	获取元素
		根据id获取 --->getElementById()
		根据class获取 --->getElementsByClass()
		根据标签名获取  --->getElementsTagName()
		根据属性name值获取 --->getElementsName()

	const let var 的区别
		var 定义的变量会被挂载到window上 let const定义的不会被挂载到windo上
		var 存在变量提升，在未定义前使用是undefined不会报错
		let const 不存在变量提升，在未定义前使用会报错，变量未定义
		let const声明变量会形成块作用域，在作用域外部调用会报错
		在同一个作用域下，let,const不能声明同名变量，var可以
		const 声明变量时必须赋值，且不能用null占位，且不能修改

	bind call apply 的区别
		都是用于改变this的指向，第一个参数都是this要指向的对象，都可以利用后续参数传参
		call apply都是对函数的直接调用，而bind方法返回的还是一个函数，后面需要根()调用
		call后续的传参和函数值一一对应，apply后续参数是一个数组，数组中的数据和函数中的参数一一对应。bind可以和call一样传值，也可以再()中传值

	new关键字
		通过new关键字创建的对象和构造函数之间建立了一条原型链，原型链的建立，让原本孤立的对象有了依赖和继承能力。
		第一步建立一个空对象
		第二步，将建立的空对象__proto__指向构造函数的原型对象，

	深拷贝和浅拷贝
		浅拷贝就是拷贝了对象的引用，当原对象改变时，拷贝对象也会发生改变。
		深拷贝是重新申请了一块内存，内容和原对象一样，更改原对象，拷贝对象不会发生变法
		浅拷贝方法：
			1.直接赋值 a=b //b浅拷贝给了a
			2.es6 object.assign()  var a  ={name:'hello'} var b = object.assign({},a) //只有一级属性时是深拷贝，有二级属性时是深拷贝


	node属性
		前 --> previousSibling
		后 --> nextSibling
		父 -->parentNode
		子 -->childNode、children、fristChild、lastChild

		操作
		appendChild
		insertbefore
		removeChild
		replaceChild
		innerHtml
		innerText

		创建
		createElement

		属性操作
			getAttribute
			setAttribute
			removeAttribute
			hasAttribute

		w3c
			标签闭合，标签小写，不乱嵌套，使用外链css和js，结构行为表现的分离

		HTTP协议

		Vue
			脚手架安装
				npm install -g vue-cli
			项目创建
				vue init webpack<模板名> <项目名>  \\ vue create <项目名>
			linux下，npm install 安装模块
			v-if v-show
				v-if是节点的创建和销毁
				v-show是节点的隐藏和显示
				根据节点是否频繁切换状态决定使用谁
			v-for 必须使用key
				使用key为了保证diff操作更加准确和快速，可以减少渲染次数，提升效率

			生命周期
				beforeCreate 此阶段是实例初始化之后，此时数据和事件机制还未形成，无法获取dom
				created 此阶段的vue实例已经创建，但是还不能获取dom，只是js内存中的一个变量，还未开始渲染
				beforeMounted 

		mvvc
			model 数据来源，服务器上业务逻辑操作
			view 界面页面
			viewModel view和model的核心枢纽
			

		es6
			使用const/let声明变量
			使用模板运算符，不使用++嵌套连接字符串，需要反引号和字符串插值${}
			const first = 'Adrian';
			const last = 'Mejia';
			console.log(`Your name is ${first} ${last}.`);
			解构赋值
			const array = [1,2,3,4];
			const [first,,third] = array;
			console.log(first,third); // 1,3

		css
			清除浮动
				父标签添加overflow:hidden
				添加一个空的块级元素，设置clear:both	
				父标签添加伪类after，设置display：block，clear:both

		javascript跨域特性
			1.jsonp 使用<script>标签跨域特性，可以不受限制的从其他域中获取资源，还有如<img>标签
			2.document.domain 用于主域名相同，子域名不相同的跨域中
			3.windows.name 




			原型链
			继承的实现
			数据类型
			var、const、let 对比
			new 的过程
			this 指向问题
			bind 实现方式
			闭包	
			事件循环
			类型判断
			手写 Promise	

			一个页面有父子组件，进入之后的渲染顺序触发的生命周期是什么样的
			keep-alive，如果只想要router-view里面的某个组件被缓存，怎么做
			组件通信中的eventbus原理是什么
			vue diff简单讲讲
			3.0proxy 讲讲，和 2.0 区别（广度）
			data为什么是函数
			常用vue api原理(包括不限于nextTick,watch，computed)

			涉及到的编码题：

				call，apply，bind
				节流，防抖
				class实现

			其余对于工程上面的考量，因为我是用webpack打包的，所以会问一下loader，plugin的区别，怎么实现loader，plugin，自己有没有写过，webpack整个流程是什么样的，这边建议自己去手写个简单的webpack玩玩，就全知道了，本质上就是广度递归而已

			vue如何实现组件封装
			一个动态拖拽的场景，抓取一个div之后如何显示最靠近的div的基线，就是一条虚线，我这里用队列的方式解决
			图片，视频断点续传的一些问题
			因为我github有手写webpack，针对我写的webpack问了几个问题，关于hook和生命周期的

			webpack整个打包流程是怎么样的，聊聊闭包，箭头函数，es6这些基础题




			https://www.jianshu.com/p/52103187aac6